{
    "analysis": {
        "analyzer.js": {
            "content": "const analysisQueue = require('./analysis-queue');\nconst converter = require('../converter');\nconst depthSelector = require('./depth-selector');\nconst pgnAnalyzer = require('./pgn-analyzer');\n\nlet ricpaClient;\nlet pingUrl;\n\nfunction analyze(item) {\n  if(ricpaClient) {\n    if(pgnAnalyzer.areMovesWithinLimit(item.moves)) {\n      item.pingUrl = pingUrl;\n      console.log(`POST '${item.fen}' w/ depth ${item.depth} to ${ricpaClient.config.fullpath}`);\n      ricpaClient.postFen(item);\n    } else {\n      console.log(`too long pgn for opening for analysis: ${item.moves.join(',')}`);\n      analysisQueue.delete(item.fen);\n    }\n  } else {\n    console.error('set ricpaClient settings in app.config.json to analyze positions');\n  }\n}\n\nconst analyzeLater = function(moves, base, priority) {\n  return new Promise((resolve, reject) => {\n    if (moves) {\n      if (!base) reject('analyzeLater is called with moves without base');\n      try {\n        let movesList = pgnAnalyzer.splitSequentially(base, moves);\n        movesList = movesList.filter(pgnAnalyzer.areMovesWithinLimit);\n        movesList.forEach(function(moves) {\n          const queueItem = {\n            fen: converter.moves2fen(moves),\n            moves,\n            depth: depthSelector.getMinDepthRequired()\n          };\n          analysisQueue.add(queueItem, priority);\n        });\n      }\n      catch (err) {\n        reject(err);\n      }\n      resolve();\n    } else {\n      reject();\n    }\n  });\n};\n\nfunction setSettings(settings) {\n  ricpaClient = settings.ricpaClient;\n  pingUrl = settings.pingUrl;\n}\n\nmodule.exports = { analyze, analyzeLater, setSettings};\n\n"
        },
        "queue-serializer.js": {
            "content": "const smartStringifier = require('smart-stringifier');\n\nmodule.exports.stringify = function(queue) {\n  return smartStringifier.stringify({q: queue});\n};\n\nmodule.exports.parse = function(str) {\n  const parsed = JSON.parse(str).q;\n  parsed[2]=[];\n  parsed[3]=[];\n  return parsed;\n};\n"
        },
        "endgame-analyzer.js": {
            "content": "// analyzes endgame\n\nvar fenAnalyzer = require('fen-analyzer');\n\nconst MAX_PIECES = 7;\n\nmodule.exports.isEndgame = function(fen) {\n  let piecesCount = fenAnalyzer.getPiecesCount(fen);\n  return (piecesCount <= MAX_PIECES);\n};\n"
        },
        "pgn-analyzer.js": {
            "content": "const baseIterator = require('../chessbase/base-iterator');\n\nconst DEFAULT_PLY_LIMIT = 80; // 40 moves, 80 ply\n\nlet plyLimit = DEFAULT_PLY_LIMIT;\n\n// checks if the moves list is optimal and returns true/false/undefined\nfunction isOptimal(moves, base) {\n  if (moves && moves.length) {\n    let position = base;\n    const possibilities = {white: true, black: true};\n    for (let i = 0; i < moves.length; i++) {\n      let move = moves[i];\n      let bestMove = position && position.s && position.s.length && position.s[0].m;\n      if (move !== bestMove) {\n        if (i % 2 === 0) {\n          possibilities.white = false;\n        } else {\n          possibilities.black = false;\n        }\n      }\n      if (!possibilities.white && !possibilities.black) {\n        return bestMove ? false : undefined;\n      }\n      position = baseIterator.findSubPositionObject(position, move);\n    }\n  }\n  return true;\n}\n\nfunction cutToMatchLimit(moves) {\n  return moves.slice(0, plyLimit - 1);\n}\n\nfunction setMovesLimit(newMovesLimit) {\n  plyLimit = newMovesLimit * 2;\n}\n\nfunction splitSequentially(base, moves) {\n  let list = [];\n  let positionObject = base;\n  moves.forEach(function(move, index) {\n    let subObject = baseIterator.findSubPositionObject(positionObject, move);\n    if (subObject === null) {\n      let movesToAdd = moves.slice(0, index + 1);\n      list.push(movesToAdd);\n    }\n    positionObject = subObject;\n  });\n  if (list.length === 0)\n    list.push(moves);\n  return list;\n}\n\nfunction areMovesWithinLimit(moves) {\n  if(Array.isArray(moves)) {\n    return moves.length < plyLimit;\n  } else {\n    throw new Error(`List of moves has to be provided, but '${moves}' was provided instead`);\n  }\n}\n\nmodule.exports = { areMovesWithinLimit, cutToMatchLimit, isOptimal, setMovesLimit, splitSequentially };\n"
        },
        "synchronizer.js": {
            "content": "var fs = require('fs');\nvar queueSerializer = require('./queue-serializer');\n\n/**\n * loads queue from file\n * @param {string} filename - filename with json where queue is stored\n * @param {object} defaultQueue - json object with default queue to be used if file could not be read\n * @return {object} loaded queue\n */\nexports.loadQueue = function(filename, defaultQueue) {\n  try {\n    var fileContent = fs.readFileSync(filename);\n    return queueSerializer.parse(fileContent);\n  } catch (err) {\n    console.error('Could not load analysis queue: ' + err);\n    return defaultQueue;\n  }\n};\n\n/**\n * Saves a queue into file asynchronously\n * @param {string} filename - filename to save a queue\n * @param {object} queue - queue to save\n */\nexports.saveQueue = function(filename, queue) {\n  try {\n    fs.writeFileSync(filename, queueSerializer.stringify(queue));\n  } catch (err) {\n    console.error('Could not save analysis queue: ' + err);\n  }\n};\n"
        },
        "analysis-queue.js": {
            "content": "const FenQueue = require('fen-queue');\n\nmodule.exports = new FenQueue();\n"
        },
        "depth-selector.js": {
            "content": "'use strict';\n\nconst MAX_DEPTH = 300;\nconst INCREMENT = 4;\nconst baseIterator = require('../../app/chessbase/base-iterator');\n\nlet defaultDepth = 40;\n\nmodule.exports.getDepthToAnalyze = function(pathOfMoves, base) {\n  let positionObject = baseIterator.findPositionObject(pathOfMoves, base);\n  if (positionObject && Object.prototype.hasOwnProperty.call(positionObject, 'e') && \n    Object.prototype.hasOwnProperty.call(positionObject.e, 'd') &&\n    (positionObject.e.d >= defaultDepth)) {\n    return positionObject.e.d + INCREMENT;\n  }\n  return defaultDepth;\n};\n\nexports.MAX_DEPTH = MAX_DEPTH;\n\nexports.setDefaultDepth = newDefaultDepth => {\n  defaultDepth = newDefaultDepth;\n};\n\nexports.getMinDepthRequired = () => {\n  return defaultDepth;\n};\n"
        },
        "queue-processing-strategy.js": {
            "content": "class QueueProcessingStrategy{\n  constructor({pgnAnalyzer, baseProvider}){\n    this.pgnAnalyzer = pgnAnalyzer;\n    this.baseProvider = baseProvider;\n  }\n  isInteresting(moves) {\n    return this.pgnAnalyzer.isOptimal(moves, this.baseProvider.getBase());\n  }\n}\n\nmodule.exports = QueueProcessingStrategy;"
        },
        "analysis-priority.js": {
            "content": "var AnalysisPriority = {\n    Emergency: 0,\n    ExternalRequestsForNewPositions: 1,\n    OptimizationOfNotAnalyzedEnough: 2,\n    MainLineOptimization: 3\n};\n\nmodule.exports = AnalysisPriority;\n"
        },
        "external-evaluation.js": {
            "content": "class ExternalEvaluation{\n  constructor(filename){\n    this.filename = filename;\n  }\n  getFen() {\n  }\n}\n\nmodule.exports = ExternalEvaluation;\n"
        }
    },
    "converter.js": {
        "content": "const Chess = require(\"chess.js\").Chess;\nconst fenAnalyzer = require(\"fen-analyzer\");\n\nclass Converter {\n  constructor(options) {\n    this.logPeriod = options ? options.logPeriod : 1000;\n  }\n  moves2fen(moves) {\n    if (moves && \"length\" in moves) {\n      const chess = new Chess();\n      moves.forEach((move) => chess.move(move));\n      const fen = fenAnalyzer.normalize(chess.fen());\n      return fen;\n    } else {\n      console.error(`Incorrect moves are supplied to moves2fen: ${moves}`);\n      return null;\n    }\n  }\n  json2fenbase(jsonbase, fenbase) {\n    let positionsQueue = [];\n    let positionCount = 0;\n\n    const addFens = (position) => {\n      let chess = new Chess(position.fen);\n      chess.move(position.m);\n      let fen = chess.fen();\n      let bestMove = position.s && position.s.length && position.s[0].m;\n      if (bestMove && position.e) {\n        fenbase.add({\n          fen,\n          bestMove,\n          score: position.e.v,\n          depth: position.e.d,\n        });\n        positionCount++;\n        if (positionCount % this.logPeriod == 0) {\n          console.log(\n            `${positionCount} => ${fenbase.size} in queue: ${positionsQueue.length}`\n          );\n        }\n        position.s[0].fen = fen;\n        addFens(position.s[0]);\n        for (let i = 1; i < position.s.length; i++) {\n          position.s[i].fen = fen;\n          positionsQueue.push(position.s[i]);\n        }\n      }\n    };\n    if (jsonbase) {\n      const baseCopy = JSON.parse(JSON.stringify(jsonbase));\n      positionsQueue.push(baseCopy);\n      while (positionsQueue.length) {\n        let position = positionsQueue.shift();\n        addFens(position);\n      }\n      console.log(\n        `${positionCount} position objects corresponds to ${fenbase.size} unique positions`\n      );\n    } else {\n      console.error(\"could not convert null jsonbase\");\n    }\n  }\n}\n\nmodule.exports = new Converter();\n"
    },
    "usage-statistics-synchronizer.js": {
        "content": "'use strict';\n\nconst fs = require('fs');\nconst FILE_NAME = 'usage-statistics.json';\n\nmodule.exports.FILE_NAME = FILE_NAME;\n\nmodule.exports.save = function(content) {\n  if (typeof content === 'object') {\n    content = JSON.stringify(content);\n  }\n  fs.writeFile(FILE_NAME, content, err => {\n    if (err) console.error(err);\n  });\n};\n\nmodule.exports.load = function() {\n  let result = null;\n  try {\n    let content = fs.readFileSync(FILE_NAME);\n    result = JSON.parse(content);\n  } catch (err) {\n    console.error('Usage statistics could not be loaded');\n  }\n  return result;\n};\n"
    },
    "config.js": {
        "content": "'use strict';\n\nconst filename = './app.config.json';\nconst fs = require('fs');\nlet buffer = fs.readFileSync(filename);\nlet jsonContent = JSON.parse(buffer);\nmodule.exports = jsonContent;\n"
    },
    "usage-statistics.js": {
        "content": "'use strict';\n\nlet logs = [];\nvar recentSynchronizer;\n\nmodule.exports.registerBaseRequest = function(userID) {\n  var logData = {userID: userID, date: Date.now()};\n  console.log('base requested for \"' + logData.userID+'\" at ' + logData.date);\n  logs.push(logData);\n  this.save(recentSynchronizer);\n};\n\nmodule.exports.getUsersCount = function() {\n  var uniqueUsers = new Set();\n  var now = new Date();\n  var week = 7*24*60*60*1000;\n  logs.forEach(function(logData) {\n    if(logData.date > (now - week) ) {\n      uniqueUsers.add(logData.userID);\n    }\n  });\n  return uniqueUsers.size;\n};\n\nmodule.exports.reset = function() {\n  logs = [];\n};\n\nmodule.exports.getJSON = function() {\n  return {logs: logs};\n};\n\nmodule.exports.save = function(synchronizer) {\n  if(synchronizer && synchronizer.save) {\n    synchronizer.save(this.getJSON());\n  }\n};\n\nmodule.exports.load = function(synchronizer) {\n  recentSynchronizer = synchronizer;\n  if(synchronizer && synchronizer.load) {\n    let data = synchronizer.load();\n    if(data && data.logs) {\n      logs = data.logs;\n    }\n  }\n};\n"
    },
    "request-processor.js": {
        "content": "var analysisPriority = require(\"./analysis/analysis-priority\");\n\nclass RequestProcessor {\n  constructor({ baseManager, queueProcessor, usageStatistics, analyzer }) {\n    this.analyzer = analyzer;\n    this.baseManager = baseManager;\n    this.queueProcessor = queueProcessor;\n    this.usageStatistics = usageStatistics;\n  }\n  getBase(req, res) {\n    let userId = new URL(req.url, \"https://hostname\").searchParams.get(\n      \"userid\"\n    );\n    res.writeHead(200, {\n      \"Content-Type\": \"text/plain\",\n      \"Access-Control-Allow-Origin\": \"*\",\n    });\n    res.end(this.baseManager.getBaseAsString());\n    this.usageStatistics.registerBaseRequest(userId);\n  }\n  getFenBase(req, res) {\n    res.writeHead(200, {\n      \"Content-Type\": \"application/json\",\n      \"Access-Control-Allow-Origin\": \"*\",\n    });\n    res.end(JSON.stringify(this.baseManager.getFenBase()));\n  }\n  getFenData(req, res) {\n    let url = new URL(req.url, \"https://hostname\");\n    let fen = url.searchParams.get(\"fen\");\n    if (fen) {\n      fen = decodeURI(fen);\n      console.log(`requesting fenData for '${fen}'`);\n      res.writeHead(200, {\n        \"Content-Type\": \"application/json\",\n        \"Access-Control-Allow-Origin\": \"*\",\n      });\n      res.end(JSON.stringify(this.baseManager.getFen({ fen })));\n    } else {\n      res.writeHead(422);\n      res.end();\n    }\n  }\n  default(res) {\n    res.writeHead(200, {\n      \"Content-Type\": \"text/plain\",\n      \"Access-Control-Allow-Origin\": \"*\",\n    });\n    res.end();\n  }\n  analyze(req, res) {\n    switch (req.method) {\n      case \"OPTIONS\":\n        res.writeHead(200, {\n          \"Access-Control-Allow-Origin\": \"*\",\n          \"Access-Control-Allow-Headers\": \"Origin, Content-Type\",\n        });\n        res.end(\"\");\n        break;\n      case \"POST\":\n        let body = \"\";\n        req.on(\"data\", (chunk) =>\n          typeof chunk == \"object\" && \"moves\" in chunk\n            ? (body = chunk)\n            : (body += chunk)\n        );\n        req.on(\"end\", () => {\n          let data = body;\n          try {\n            data = typeof body == \"string\" ? JSON.parse(body) : body;\n          } catch (err) {\n            console.error(`POST /analyze: ${err}:`, body);\n          }\n          if (data && data.moves) {\n            this.analyzer\n              .analyzeLater(\n                data.moves,\n                this.baseManager.getBase(),\n                analysisPriority.ExternalRequestsForNewPositions\n              )\n              .then(() => {\n                return this.queueProcessor.process();\n              })\n              .catch((err) => console.error(err));\n            res.writeHead(200, { \"Access-Control-Allow-Origin\": \"*\" });\n            res.end(body);\n          } else {\n            const error =\n              \"incorrect body received: \" +\n              JSON.stringify(body) +\n              '. It should be {\"moves\": []} json';\n            console.error(\"POST /analyze: \" + error, \"data: \", data);\n            res.writeHead(400, { \"Access-Control-Allow-Origin\": \"*\" });\n            res.end(error);\n          }\n        });\n        break;\n      default:\n        res.writeHead(405, { \"Access-Control-Allow-Origin\": \"*\" });\n        res.end('should be POST method with {\"moves\":[]} in the body');\n    }\n  }\n  getUsersCount(req, res) {\n    res.writeHead(200, {\n      \"Content-Type\": \"text/plain\",\n      \"Access-Control-Allow-Origin\": \"*\",\n    });\n    var usersCount = this.usageStatistics.getUsersCount();\n    res.end(String(usersCount));\n  }\n  ping(req, res) {\n    res.writeHead(200, { \"Access-Control-Allow-Origin\": \"*\" });\n    res.end(\"\");\n    this.queueProcessor.process();\n  }\n}\n\nmodule.exports = RequestProcessor;\n"
    },
    "api.js": {
        "content": "const http = require('http');\n\nfunction createMap(processor) {\n  return function(req, res) {\n    console.log(`${req.method} ${req.url}`);\n    const url = new URL(req.url, 'https://hostname');\n    switch (url.pathname) {\n    case '/api/analyze':\n      processor.analyze(req, res);\n      break;\n    case '/api/userscount':\n    case '/api/getuserscount':\n      processor.getUsersCount(req, res);\n      break;\n    case '/api/ping':\n      processor.ping(req, res);\n      break;\n    case '/api/base':\n    case '/api/getbase':\n      processor.getBase(req, res);\n      break;\n    case '/api/fenbase':\n      processor.getFenBase(req, res);\n      break;\n    case '/api/fendata':\n      processor.getFenData(req, res);\n      break;\n    default:\n      processor.default(res);\n    }\n  };\n}\n\nfunction register(requestProcessor, port) {\n  http.createServer(createMap(requestProcessor)).listen(port);\n}\n\nmodule.exports = {\n  register,\n  createMap\n};\n"
    },
    "chessbase": {
        "base-iterator.js": {
            "content": "'use strict';\n\nvar pgnAnalyzer = require('../analysis/pgn-analyzer');\n\nvar addMoves = function (result, moves, parentObject, requiredDepth, objectsToLookDeeper, base) {\n  if (parentObject.s) {\n    parentObject.s.forEach(function (childObject) {\n      var movesWithChild = moves.slice();\n      movesWithChild.push(childObject.m);\n      if (((!childObject.e && childObject.s && childObject.s.length) || (childObject.e && childObject.e.d < requiredDepth)) && (pgnAnalyzer.isOptimal(movesWithChild, base))) {\n        result.push(movesWithChild);\n      } else {\n        objectsToLookDeeper.push({ positionObject: childObject, moves: movesWithChild });\n      }\n    });\n  }\n};\n\nmodule.exports.getMovesToInsufficientEvaluationDepth = function (base, requiredDepth) {\n  const result = [];\n  const moves = [];\n  if(base.e && base.e.d < requiredDepth) {\n    result.push(moves);\n  }\n  let objectsToLookDeeper = [];\n  addMoves(result, moves, base, requiredDepth, objectsToLookDeeper, base);\n  while (objectsToLookDeeper.length > 0) {\n    const nextLevelOfObjects = [];\n    objectsToLookDeeper.forEach(function (objectData) {\n      addMoves(result, objectData.moves, objectData.positionObject, requiredDepth, nextLevelOfObjects, base);\n    });\n    objectsToLookDeeper = nextLevelOfObjects;\n  }\n  return result;\n};\n\nmodule.exports.findSubPositionObject = function (positionObject, move) {\n  if (positionObject && positionObject.s) {\n    for (var i = 0, l = positionObject.s.length; i < l; i++) {\n      if (positionObject.s[i].m == move) {\n        return positionObject.s[i];\n      }\n    }\n  }\n  return null;\n};\n\nmodule.exports.findLatestMainLine = function(base) {\n  var result = [];\n  var positionObject = base;\n  if(positionObject.s && positionObject.s.length>0) {\n    positionObject = positionObject.s[0];\n  }\n  while(positionObject && positionObject.m) {\n    result.push(positionObject.m);\n    if(positionObject.s && positionObject.s.length>0) {\n      positionObject = positionObject.s[0];\n    } else {\n      break;\n    }\n  }\n  return result;\n};\n\nmodule.exports.findMinDepthMainLinePath = function(base) {\n  let currentPath = [];\n  let candidatePath = currentPath.slice();\n  let positionObject = base;\n  let minDepth = positionObject.e.d;\n  while(positionObject && positionObject.s && positionObject.s.length) {\n    positionObject = positionObject.s[0];\n    if(positionObject && positionObject.m) {\n      currentPath.push(positionObject.m);\n      if(!pgnAnalyzer.areMovesWithinLimit(currentPath)) break;\n      if(Object.prototype.hasOwnProperty.call(positionObject, 'e') && Object.prototype.hasOwnProperty.call(positionObject.e, 'd') && positionObject.e.d < minDepth) {\n        minDepth = positionObject.e.d;\n        // copy array via slice(), ordinary '=' will assign the same array by reference\n        candidatePath = currentPath.slice();\n      }\n    }\n  }\n  return candidatePath;\n};\n\nmodule.exports.findPositionObject = function(movesPath, base) {\n  if(base && Array.isArray(movesPath)) {\n    let currentPositionObject = base;\n    for (let i = 0; i < movesPath.length; i++) {\n      currentPositionObject = this.findSubPositionObject(currentPositionObject, movesPath[i]);\n    }\n    return currentPositionObject;\n  } else {\n    return null;\n  }\n};\n\nmodule.exports.getBest = positionObject => positionObject && positionObject.s && positionObject.s[0];\n"
        },
        "evaluation.js": {
            "content": "const fs = require('fs');\n\nconst baseManager = require('./base-manager');\nconst config = require('../config');\nconst depthSelector = require('../analysis/depth-selector');\nconst endgameAnalyzer = require('../analysis/endgame-analyzer');\n\nvar evaluationLogFileName = config.evaluationsLogFile;\n\nmodule.exports.Chess = require('chess.js').Chess;\n\nmodule.exports.save = ({moves, bestMove, score, depth}) => {\n  if(bestMove) {\n    const chess = new this.Chess();\n    moves.forEach(move => chess.move(move, {sloppy: true}));\n    chess.move(bestMove, {sloppy: true});\n    if (chess.game_over() || endgameAnalyzer.isEndgame(chess.fen())) {\n      depth = depthSelector.MAX_DEPTH;\n      if (chess.in_draw) {\n        score = 0;\n      }\n    }\n    console.log(`best move for ${moves} is ${bestMove} with score/depth ${score}/${depth}`);\n    fs.appendFile(evaluationLogFileName, `${moves} ${bestMove}! ${score}/${depth}\\n`, function (err) {\n      if (err) console.error(`could not append to '${evaluationLogFileName}' :`, err);\n    });\n    baseManager.addToBase(moves, bestMove, score, depth);\n  } else {\n    console.error('Could not save evaluation, because bestMove was not provided');\n  }\n};\n"
        },
        "base-serializer.js": {
            "content": "var toReadableString = function(baseObject) {\n\tvar evaluationToString = function (positionObject) {\n\t\tif(positionObject.e){\n\t\t\tvar value = (typeof(positionObject.e.v) == \"number\") ? positionObject.e.v : '\"' + positionObject.e.v + '\"';\n\t\t\tvar evaluationPropertiesAsString = '\"v\": ' + value + ', \"d\": ' + positionObject.e.d;\n\t\t\treturn '\"e\": {' + evaluationPropertiesAsString + \"}, \";\n\t\t}\n\t\treturn \"\";\n\t};\n\tvar subItemsToString = function(positionObject, level) {\n\t\tvar result = \"\";\n\t\tif(positionObject.s) {\n\t\t\tfor(var i= 0; i<positionObject.s.length; i++) {\n\t\t\t\tif(result!=\"\") result = result + \",\\n\";\n\t\t\t\tfor(var j=0;j<level;j++) result += \" \";\n\t\t\t\tresult += '{\"m\": \"' + positionObject.s[i].m + '\", \"n\": ' + positionObject.s[i].n + ', \"c\": \"' +\n\t\t\t\t\tpositionObject.s[i].c + '\", ' + evaluationToString(positionObject.s[i]) +\n\t\t\t\t\t'\"s\": [' + subItemsToString(positionObject.s[i], level+1) + \"]}\";\n\t\t\t}\n\t\t}\n\t\tif(result!=\"\") result = \"\\n\" + result;\n\t\treturn result;\n\t};\n\tvar result = '{\"m\": \"\", \"n\": 0, \"c\": \"b\", \"t\": \"wb\", ' + evaluationToString(baseObject) + '\"s\": [';\n\tresult += subItemsToString(baseObject,0);\n\tresult += \"]}\";\n\treturn result;\n};\n\nvar toShortestString = function(baseObject) {\n\treturn JSON.stringify(baseObject);\n};\n\nmodule.exports.stringify = function(baseObject, readable){\n    if(readable) {\n        return toReadableString(baseObject)\n    } else {\n        return toShortestString(baseObject);\n    }\n};\n\nmodule.exports.parse = function(str) {\n\tvar base = {};\n\ttry {\n\t\tbase = JSON.parse(str);\n\t} catch (err) {\n\t\tconsole.error(err + \". Could not parse base from: \" + str)\n\t}\n    return base;\n};\n"
        },
        "base-manager.js": {
            "content": "const bestmovedb = require(\"bestmovedb\");\nconst fs = require(\"fs\");\nconst baseSerializer = require(\"./base-serializer\");\nconst baseOptimizer = require(\"./optimization/base-optimizer\");\nconst baseIterator = require(\"./base-iterator\");\nconst converter = require(\"../converter\");\n\nvar base = { m: \"\", n: 0, c: \"b\", t: \"wb\" };\nvar filename = \"base.json\";\n\nmodule.exports.getFen = ({ fen, depth }) => {\n  const fenData = bestmovedb.getFen({ fen, depth });\n  if (fenData && !fenData.cp) {\n    fenData.cp = fenData.score * 100;\n  }\n  return fenData;\n};\n\nmodule.exports.getFenBase = () => bestmovedb.toJSON();\n\nlet isSaving = false;\n\nmodule.exports.saveBaseSync = () => {\n  if (isSaving) return;\n  isSaving = true;\n  try {\n    const content = baseSerializer.stringify(base, true);\n    fs.writeFileSync(filename, content);\n  } catch (err) {\n    console.error(err);\n  } finally {\n    isSaving = false;\n  }\n};\n\nmodule.exports.saveBase = () => {\n  if (isSaving) return Promise.resolve();\n  return new Promise((resolve) => {\n    this.saveBaseSync();\n    resolve();\n  }).catch(console.error);\n};\n\nvar createChildPositionObject = function (parentObject, childMove, isBest) {\n  var n;\n  var c;\n  if (parentObject.c === \"w\") {\n    n = parentObject.n;\n    c = \"b\";\n  } else {\n    n = parentObject.n + 1;\n    c = \"w\";\n  }\n  var newChildObject = { m: childMove, n: n, c: c };\n  if (!parentObject.s) {\n    parentObject.s = [];\n  }\n  if (isBest) {\n    parentObject.s.unshift(newChildObject);\n  } else {\n    parentObject.s.push(newChildObject);\n  }\n  return newChildObject;\n};\n\nvar improveEvaluation = function (positionObject, evaluationObject) {\n  if (!positionObject.e || evaluationObject.d > positionObject.e.d) {\n    positionObject.e = evaluationObject;\n  }\n};\n\nmodule.exports.addToBase = (moves, bestMove, score, depth) => {\n  this.addToJsonBase(moves, bestMove, score, depth);\n  const fen = converter.moves2fen(moves);\n  bestmovedb.add({ fen, bestMove, score, depth });\n};\n\nmodule.exports.addToJsonBase = function (moves, bestAnswer, scoreValue, depth) {\n  var evaluationObject = { v: scoreValue, d: depth };\n  var positionObject = base;\n  var parent;\n  for (var i = 0; i < moves.length; i++) {\n    parent = positionObject;\n    positionObject = baseIterator.findSubPositionObject(parent, moves[i]);\n    if (!positionObject) {\n      positionObject = createChildPositionObject(parent, moves[i]);\n    }\n  }\n  if (!positionObject.e || positionObject.e.d <= evaluationObject.d) {\n    improveEvaluation(positionObject, evaluationObject);\n    parent = positionObject;\n    var index;\n    var subPositionObject = (function () {\n      if (positionObject && positionObject.s) {\n        let l = positionObject.s.length;\n        for (index = 0; index < l; index++) {\n          if (positionObject.s[index].m === bestAnswer) {\n            return positionObject.s[index];\n          }\n        }\n      }\n      return null;\n    })();\n    if (subPositionObject) {\n      positionObject.s.splice(index, 1);\n      positionObject.s.unshift(subPositionObject);\n    } else {\n      createChildPositionObject(parent, bestAnswer, true);\n    }\n    this.saveBase();\n  }\n};\n\nmodule.exports.getBase = function () {\n  return base;\n};\n\nmodule.exports.index = () => {\n  console.log(\"base index start\");\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      try {\n        converter.json2fenbase(base, bestmovedb);\n      } catch (err) {\n        reject(err);\n      }\n      console.log(\"base index finished\");\n      resolve();\n    }, 0);\n  }).catch((err) => console.error(err));\n};\n\nmodule.exports.readBase = function () {\n  try {\n    let baseFileContent = fs.readFileSync(filename);\n    base = baseSerializer.parse(baseFileContent);\n  } catch (err) {\n    console.error(\"Could not read \" + filename + \": \" + err);\n  }\n};\n\nmodule.exports.getBaseAsString = function () {\n  return baseSerializer.stringify(base);\n};\n\nmodule.exports.optimize = function ({ settings }) {\n  return baseOptimizer.optimize({ base, baseIterator, settings });\n};\n"
        },
        "optimization": {
            "draw-checker.js": {
                "content": "'use strict';\n\nmodule.exports.findPathToTheLatestNonDrawInMainLine = function(base) {\n  let path = [];\n  let positionObject = base;\n  while(positionObject) {\n    if(positionObject.s && positionObject.s.length && positionObject.s[0].m && !this.isDrawPosition(positionObject.s[0])) {\n      positionObject = positionObject.s[0];\n      path.push(positionObject.m);\n    } else {\n      break;\n    }\n  }\n  return path;\n};\n\nmodule.exports.isDrawPosition = function(positionObject) {\n  return (positionObject && positionObject.e && positionObject.e.hasOwnProperty('v') &&\n    positionObject.e.hasOwnProperty('d') &&\n    positionObject.e.v === 0 && positionObject.e.d === 300);\n}"
            },
            "main-line-optimizer.js": {
                "content": "'use strict';\n\nconst pathChecker = require('./path-checker');\nconst pgnAnalyzer = require('../../analysis/pgn-analyzer');\n\nmodule.exports.getMoves = function({base, baseIterator}) {\n  let moves = baseIterator.findLatestMainLine(base);\n  if (pathChecker.isGameOver(moves, base) || !pgnAnalyzer.areMovesWithinLimit(moves)) {\n    moves = baseIterator.findMinDepthMainLinePath(base);\n    console.log('Min depth main line path found: ' + moves.join(','));\n  } else {\n    console.log('Main line for analysis: ' + moves.join(','));\n  }\n  return moves;\n};\n"
            },
            "base-optimizer.js": {
                "content": "'use strict';\n\nconst mainLineOptimizer = require('./main-line-optimizer');\nconst analysisPriority = require('../../analysis/analysis-priority');\nconst converter = require('../../converter');\nconst depthSelector = require('../../analysis/depth-selector');\nconst analysisQueue = require('../../analysis/analysis-queue');\nlet optimizeInProgress = false;\n\nmodule.exports.optimizeSync = function({base, baseIterator}) {\n  if (optimizeInProgress) return;\n  console.log('optimization started');\n  optimizeInProgress = true;\n  if(baseIterator) {\n    let movesList = baseIterator.getMovesToInsufficientEvaluationDepth(base, depthSelector.getMinDepthRequired());\n    if (movesList && movesList.length) {\n      movesList.forEach(function(moves) {\n        analysisQueue.add(\n          { fen: converter.moves2fen(moves),\n            depth: depthSelector.getMinDepthRequired(),\n            moves\n          }, analysisPriority.OptimizationOfNotAnalyzedEnough\n        );\n      });\n    } else {\n      console.log('no positions with insufficient depth are identified');\n    }\n    const moves = mainLineOptimizer.getMoves({base, baseIterator});\n    if(moves !== undefined && 'length' in moves) {\n      console.log(`Optimizing main line: ${moves.join(',')}`);\n      analysisQueue.add(\n        {\n          fen: converter.moves2fen(moves),\n          depth: depthSelector.getDepthToAnalyze(moves, base),\n          moves\n        }, analysisPriority.MainLineOptimization\n      );\n    } else {\n      console.log('nothing to optimize in main line');\n    }\n  } else {\n    console.error('baseIterator is not defined');\n  }\n  optimizeInProgress = false;\n};\n\nmodule.exports.optimize = function({base, baseIterator, settings = {}}) {\n  return new Promise((resolve) => {\n    if(settings.optimize) {\n      this.optimizeSync({base, baseIterator});\n    }\n    resolve();\n  }).catch(err => console.error(err));\n};\n"
            },
            "path-checker.js": {
                "content": "'use strict';\n\nconst MAX_DEPTH = 300;\n\nmodule.exports.isCheckmate = function(pathToAnalyze) {\n  if (pathToAnalyze.length > 0) {\n    var theLatest = pathToAnalyze[pathToAnalyze.length - 1];\n    if (theLatest.endsWith('#')) {\n      return true;\n    }\n  }\n  return false;\n};\n\nmodule.exports.isMaxDepth = function(pathToCheck, base) {\n  let positionObject = base;\n  for(let index = 0; positionObject; index++) {\n    if(isMaxDepthForObject(positionObject)){\n      return true;\n    }\n    if(positionObject.s && positionObject.s.length && index < pathToCheck.length) {\n      positionObject = positionObject.s.find(obj => obj.m == pathToCheck[index]);\n    } else {\n      break;\n    }\n  }\n  return false;\n};\n\nconst isMaxDepthForObject = positionObject => (\n  positionObject && \n  Object.prototype.hasOwnProperty.call(positionObject, 'e') &&\n  Object.prototype.hasOwnProperty.call(positionObject.e, 'd') &&\n  positionObject.e.d >= MAX_DEPTH);\n\nmodule.exports.isGameOver = function(movesPath, base) {\n  return (this.isCheckmate(movesPath) || this.isMaxDepth(movesPath, base));\n};\n"
            }
        }
    }
}